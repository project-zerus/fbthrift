/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "frozen_types.h"

#include <algorithm>
#include <string.h>

namespace apache { namespace thrift { namespace frozen { namespace schema {

const uint64_t Field::_reflection_id;
void Field::_reflection_register(::apache::thrift::reflection::Schema& schema) {
   ::apache::thrift::frozen::schema::frozen_reflection_::reflectionInitializer_2361056240366028172(schema);
}

bool Field::operator == (const Field & rhs) const {
  if (!(this->layoutId == rhs.layoutId))
    return false;
  if (!(this->offset == rhs.offset))
    return false;
  return true;
}

void Field::__clear() {
  layoutId = 0;
  offset = 0;
  __isset.__clear();
}
void swap(Field &a, Field &b) {
  using ::std::swap;
  (void)a;
  (void)b;
  swap(a.layoutId, b.layoutId);
  swap(a.offset, b.offset);
  swap(a.__isset, b.__isset);
}

void merge(const Field& from, Field& to) {
  using apache::thrift::merge;
  if (from.__isset.layoutId) {
    merge(from.layoutId, to.layoutId);
    to.__isset.layoutId = true;
  }
  if (from.__isset.offset) {
    merge(from.offset, to.offset);
    to.__isset.offset = true;
  }
}

void merge(Field&& from, Field& to) {
  using apache::thrift::merge;
  if (from.__isset.layoutId) {
    merge(std::move(from.layoutId), to.layoutId);
    to.__isset.layoutId = true;
  }
  if (from.__isset.offset) {
    merge(std::move(from.offset), to.offset);
    to.__isset.offset = true;
  }
}

const uint64_t Layout::_reflection_id;
void Layout::_reflection_register(::apache::thrift::reflection::Schema& schema) {
   ::apache::thrift::frozen::schema::frozen_reflection_::reflectionInitializer_3221448234020655692(schema);
}

bool Layout::operator == (const Layout & rhs) const {
  if (!(this->size == rhs.size))
    return false;
  if (!(this->bits == rhs.bits))
    return false;
  if (!(this->fields == rhs.fields))
    return false;
  if (!(this->typeName == rhs.typeName))
    return false;
  return true;
}

void Layout::__clear() {
  size = 0;
  bits = 0;
  fields.clear();
  typeName = "";
  __isset.__clear();
}
void swap(Layout &a, Layout &b) {
  using ::std::swap;
  (void)a;
  (void)b;
  swap(a.size, b.size);
  swap(a.bits, b.bits);
  swap(a.fields, b.fields);
  swap(a.typeName, b.typeName);
  swap(a.__isset, b.__isset);
}

void merge(const Layout& from, Layout& to) {
  using apache::thrift::merge;
  if (from.__isset.size) {
    merge(from.size, to.size);
    to.__isset.size = true;
  }
  if (from.__isset.bits) {
    merge(from.bits, to.bits);
    to.__isset.bits = true;
  }
  if (from.__isset.fields) {
    merge(from.fields, to.fields);
    to.__isset.fields = true;
  }
  if (from.__isset.typeName) {
    merge(from.typeName, to.typeName);
    to.__isset.typeName = true;
  }
}

void merge(Layout&& from, Layout& to) {
  using apache::thrift::merge;
  if (from.__isset.size) {
    merge(std::move(from.size), to.size);
    to.__isset.size = true;
  }
  if (from.__isset.bits) {
    merge(std::move(from.bits), to.bits);
    to.__isset.bits = true;
  }
  if (from.__isset.fields) {
    merge(std::move(from.fields), to.fields);
    to.__isset.fields = true;
  }
  if (from.__isset.typeName) {
    merge(std::move(from.typeName), to.typeName);
    to.__isset.typeName = true;
  }
}

const uint64_t Schema::_reflection_id;
void Schema::_reflection_register(::apache::thrift::reflection::Schema& schema) {
   ::apache::thrift::frozen::schema::frozen_reflection_::reflectionInitializer_6060681111115730220(schema);
}

bool Schema::operator == (const Schema & rhs) const {
  if (!(this->fileVersion == rhs.fileVersion))
    return false;
  if (!(this->relaxTypeChecks == rhs.relaxTypeChecks))
    return false;
  if (!(this->layouts == rhs.layouts))
    return false;
  if (!(this->rootLayout == rhs.rootLayout))
    return false;
  return true;
}

void Schema::__clear() {
  fileVersion = 0;
  relaxTypeChecks = false;
  layouts.clear();
  rootLayout = 0;
  __isset.__clear();
}
void swap(Schema &a, Schema &b) {
  using ::std::swap;
  (void)a;
  (void)b;
  swap(a.fileVersion, b.fileVersion);
  swap(a.relaxTypeChecks, b.relaxTypeChecks);
  swap(a.layouts, b.layouts);
  swap(a.rootLayout, b.rootLayout);
  swap(a.__isset, b.__isset);
}

void merge(const Schema& from, Schema& to) {
  using apache::thrift::merge;
  if (from.__isset.fileVersion) {
    merge(from.fileVersion, to.fileVersion);
    to.__isset.fileVersion = true;
  }
  if (from.__isset.relaxTypeChecks) {
    merge(from.relaxTypeChecks, to.relaxTypeChecks);
    to.__isset.relaxTypeChecks = true;
  }
  if (from.__isset.layouts) {
    merge(from.layouts, to.layouts);
    to.__isset.layouts = true;
  }
  if (from.__isset.rootLayout) {
    merge(from.rootLayout, to.rootLayout);
    to.__isset.rootLayout = true;
  }
}

void merge(Schema&& from, Schema& to) {
  using apache::thrift::merge;
  if (from.__isset.fileVersion) {
    merge(std::move(from.fileVersion), to.fileVersion);
    to.__isset.fileVersion = true;
  }
  if (from.__isset.relaxTypeChecks) {
    merge(std::move(from.relaxTypeChecks), to.relaxTypeChecks);
    to.__isset.relaxTypeChecks = true;
  }
  if (from.__isset.layouts) {
    merge(std::move(from.layouts), to.layouts);
    to.__isset.layouts = true;
  }
  if (from.__isset.rootLayout) {
    merge(std::move(from.rootLayout), to.rootLayout);
    to.__isset.rootLayout = true;
  }
}

}}}} // namespace
