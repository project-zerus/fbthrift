/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "reflection_types.h"

#include <algorithm>
#include <string.h>

namespace apache { namespace thrift { namespace reflection {

int _kTypeValues[] = {
  TYPE_VOID,
  TYPE_STRING,
  TYPE_BOOL,
  TYPE_BYTE,
  TYPE_I16,
  TYPE_I32,
  TYPE_I64,
  TYPE_DOUBLE,
  TYPE_ENUM,
  TYPE_LIST,
  TYPE_SET,
  TYPE_MAP,
  TYPE_STRUCT,
  TYPE_SERVICE,
  TYPE_PROGRAM,
  TYPE_FLOAT
};

const char* _kTypeNames[] = {
  "TYPE_VOID",
  "TYPE_STRING",
  "TYPE_BOOL",
  "TYPE_BYTE",
  "TYPE_I16",
  "TYPE_I32",
  "TYPE_I64",
  "TYPE_DOUBLE",
  "TYPE_ENUM",
  "TYPE_LIST",
  "TYPE_SET",
  "TYPE_MAP",
  "TYPE_STRUCT",
  "TYPE_SERVICE",
  "TYPE_PROGRAM",
  "TYPE_FLOAT"
};

const std::map<int, const char*> _Type_VALUES_TO_NAMES(apache::thrift::TEnumIterator<int>(16, _kTypeValues, _kTypeNames), apache::thrift::TEnumIterator<int>(-1, NULL, NULL));

const std::map<const char*, int, apache::thrift::ltstr> _Type_NAMES_TO_VALUES(apache::thrift::TEnumInverseIterator<int>(16, _kTypeValues, _kTypeNames), apache::thrift::TEnumInverseIterator<int>(-1, NULL, NULL));

}}} // namespace
namespace apache { namespace thrift {
template<>
const char* TEnumTraitsBase< ::apache::thrift::reflection::Type>::findName( ::apache::thrift::reflection::Type value) {
return findName( ::apache::thrift::reflection::_Type_VALUES_TO_NAMES, value);
} 

template<>
bool TEnumTraitsBase< ::apache::thrift::reflection::Type>::findValue(const char* name,  ::apache::thrift::reflection::Type* out) {
return findValue( ::apache::thrift::reflection::_Type_NAMES_TO_VALUES, name, out);
} 
}} // apache::thrift 

namespace apache { namespace thrift { namespace reflection {
const uint64_t StructField::_reflection_id;
void StructField::_reflection_register(::apache::thrift::reflection::Schema& schema) {
   ::apache::thrift::reflection::reflection_reflection_::reflectionInitializer_214309804125196972(schema);
}

bool StructField::operator == (const StructField & rhs) const {
  if (!(this->isRequired == rhs.isRequired))
    return false;
  if (!(this->type == rhs.type))
    return false;
  if (!(this->name == rhs.name))
    return false;
  if (__isset.annotations != rhs.__isset.annotations)
    return false;
  else if (__isset.annotations && !(annotations == rhs.annotations))
    return false;
  if (!(this->order == rhs.order))
    return false;
  return true;
}

void StructField::__clear() {
  isRequired = 0;
  type = 0;
  name = "";
  annotations.clear();
  order = 0;
  __isset.__clear();
}
void swap(StructField &a, StructField &b) {
  using ::std::swap;
  (void)a;
  (void)b;
  swap(a.isRequired, b.isRequired);
  swap(a.type, b.type);
  swap(a.name, b.name);
  swap(a.annotations, b.annotations);
  swap(a.order, b.order);
  swap(a.__isset, b.__isset);
}

void merge(const StructField& from, StructField& to) {
  using apache::thrift::merge;
  if (from.__isset.isRequired) {
    merge(from.isRequired, to.isRequired);
    to.__isset.isRequired = true;
  }
  if (from.__isset.type) {
    merge(from.type, to.type);
    to.__isset.type = true;
  }
  if (from.__isset.name) {
    merge(from.name, to.name);
    to.__isset.name = true;
  }
  if (from.__isset.annotations) {
    merge(from.annotations, to.annotations);
    to.__isset.annotations = true;
  }
  if (from.__isset.order) {
    merge(from.order, to.order);
    to.__isset.order = true;
  }
}

void merge(StructField&& from, StructField& to) {
  using apache::thrift::merge;
  if (from.__isset.isRequired) {
    merge(std::move(from.isRequired), to.isRequired);
    to.__isset.isRequired = true;
  }
  if (from.__isset.type) {
    merge(std::move(from.type), to.type);
    to.__isset.type = true;
  }
  if (from.__isset.name) {
    merge(std::move(from.name), to.name);
    to.__isset.name = true;
  }
  if (from.__isset.annotations) {
    merge(std::move(from.annotations), to.annotations);
    to.__isset.annotations = true;
  }
  if (from.__isset.order) {
    merge(std::move(from.order), to.order);
    to.__isset.order = true;
  }
}

const uint64_t DataType::_reflection_id;
void DataType::_reflection_register(::apache::thrift::reflection::Schema& schema) {
   ::apache::thrift::reflection::reflection_reflection_::reflectionInitializer_4733295045172396908(schema);
}

bool DataType::operator == (const DataType & rhs) const {
  if (!(this->name == rhs.name))
    return false;
  if (__isset.fields != rhs.__isset.fields)
    return false;
  else if (__isset.fields && !(fields == rhs.fields))
    return false;
  if (__isset.mapKeyType != rhs.__isset.mapKeyType)
    return false;
  else if (__isset.mapKeyType && !(mapKeyType == rhs.mapKeyType))
    return false;
  if (__isset.valueType != rhs.__isset.valueType)
    return false;
  else if (__isset.valueType && !(valueType == rhs.valueType))
    return false;
  if (__isset.enumValues != rhs.__isset.enumValues)
    return false;
  else if (__isset.enumValues && !(enumValues == rhs.enumValues))
    return false;
  return true;
}

void DataType::__clear() {
  name = "";
  fields.clear();
  mapKeyType = 0;
  valueType = 0;
  enumValues.clear();
  __isset.__clear();
}
void swap(DataType &a, DataType &b) {
  using ::std::swap;
  (void)a;
  (void)b;
  swap(a.name, b.name);
  swap(a.fields, b.fields);
  swap(a.mapKeyType, b.mapKeyType);
  swap(a.valueType, b.valueType);
  swap(a.enumValues, b.enumValues);
  swap(a.__isset, b.__isset);
}

void merge(const DataType& from, DataType& to) {
  using apache::thrift::merge;
  if (from.__isset.name) {
    merge(from.name, to.name);
    to.__isset.name = true;
  }
  if (from.__isset.fields) {
    merge(from.fields, to.fields);
    to.__isset.fields = true;
  }
  if (from.__isset.mapKeyType) {
    merge(from.mapKeyType, to.mapKeyType);
    to.__isset.mapKeyType = true;
  }
  if (from.__isset.valueType) {
    merge(from.valueType, to.valueType);
    to.__isset.valueType = true;
  }
  if (from.__isset.enumValues) {
    merge(from.enumValues, to.enumValues);
    to.__isset.enumValues = true;
  }
}

void merge(DataType&& from, DataType& to) {
  using apache::thrift::merge;
  if (from.__isset.name) {
    merge(std::move(from.name), to.name);
    to.__isset.name = true;
  }
  if (from.__isset.fields) {
    merge(std::move(from.fields), to.fields);
    to.__isset.fields = true;
  }
  if (from.__isset.mapKeyType) {
    merge(std::move(from.mapKeyType), to.mapKeyType);
    to.__isset.mapKeyType = true;
  }
  if (from.__isset.valueType) {
    merge(std::move(from.valueType), to.valueType);
    to.__isset.valueType = true;
  }
  if (from.__isset.enumValues) {
    merge(std::move(from.enumValues), to.enumValues);
    to.__isset.enumValues = true;
  }
}

const uint64_t Schema::_reflection_id;
void Schema::_reflection_register(::apache::thrift::reflection::Schema& schema) {
   ::apache::thrift::reflection::reflection_reflection_::reflectionInitializer_6902704939566307148(schema);
}

bool Schema::operator == (const Schema & rhs) const {
  if (!(this->dataTypes == rhs.dataTypes))
    return false;
  if (!(this->names == rhs.names))
    return false;
  return true;
}

void Schema::__clear() {
  dataTypes.clear();
  names.clear();
  __isset.__clear();
}
void swap(Schema &a, Schema &b) {
  using ::std::swap;
  (void)a;
  (void)b;
  swap(a.dataTypes, b.dataTypes);
  swap(a.names, b.names);
  swap(a.__isset, b.__isset);
}

void merge(const Schema& from, Schema& to) {
  using apache::thrift::merge;
  if (from.__isset.dataTypes) {
    merge(from.dataTypes, to.dataTypes);
    to.__isset.dataTypes = true;
  }
  if (from.__isset.names) {
    merge(from.names, to.names);
    to.__isset.names = true;
  }
}

void merge(Schema&& from, Schema& to) {
  using apache::thrift::merge;
  if (from.__isset.dataTypes) {
    merge(std::move(from.dataTypes), to.dataTypes);
    to.__isset.dataTypes = true;
  }
  if (from.__isset.names) {
    merge(std::move(from.names), to.names);
    to.__isset.names = true;
  }
}

}}} // namespace
